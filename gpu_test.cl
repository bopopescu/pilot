#define x2_ca     -0.5963369f // ACDEFGHIKLMNPQRSTVWY
#define x2_cb     -0.0000000f // ACDEFHIKLMNQRSTVWY
#define x2_cb_p    0.1789471f
#define x2_cd1     2.2108445f // FY
#define x2_cd1_w   2.3323410f
#define x2_cd2     2.2106900f // FY
#define x2_cd2_h   2.4090189f
#define x2_cd2_l   2.0251100f
#define x2_cd2_w   2.3925496f
#define x2_cd      2.0815779f // EIKLQR
#define x2_cd_p    1.7278786f
#define x2_ce1     3.5923965f // FY
#define x2_ce1_h   3.5471396f
#define x2_ce2     3.5920500f // FY
#define x2_ce2_w   3.7037366f
#define x2_ce3_w   2.1713794f
#define x2_ce_k    0.9743982f
#define x2_ce_m    0.7206807f
#define x2_cg2    -0.4799299f // ITV
#define x2_cg      1.5172470f // DEFHIKLMNQRVWY
#define x2_cg_p    1.4206848f
#define x2_ch2_w   4.5487107f
#define x2_cz2_w   4.7985800f
#define x2_cz3_w   3.2693045f
#define x2_cz      4.2820440f // FY
#define x2_cz_r   -0.2871352f
#define x2_c      -1.5172358f // ACDEFGHIKLMNPQRSTVWY
#define x2_nd1_h   2.2609087f
#define x2_nd2_n   2.1011602f
#define x2_ne1_w   3.6481941f
#define x2_ne2_h   3.6630869f
#define x2_ne2_q   3.4056457f
#define x2_ne_r    1.0328361f
#define x2_nh1_r  -0.7030185f
#define x2_nh2_r  -1.1638662f
#define x2_nv_p    0.4047081f
#define x2_nz_k   -0.3772760f
#define x2_n       0.4622142f // ACDEFGHIKLMNPQRSTVWY
#define x2_od1     2.1209516f // DN
#define x2_od2_d   2.0910957f
#define x2_oe1     1.3244862f // EQ
#define x2_oe2_e   3.2825415f
#define x2_og      1.4003816f // ST
#define x2_oh_y    5.6580058f
#define x2_o      -1.0924196f // ACDEFGHIKLMNPQRSTVWY
#define x2_sd_m    2.2125427f
#define x2_sg_c    1.8084373f

#define y2_ca      1.4084445f // ACDEFGHIKLMNPQRSTVWY
#define y2_cb      0.0000000f // ACDEFHIKLMNQRSTVWY
#define y2_cb_p    0.0887525f
#define y2_cd1     1.2013461f // FY
#define y2_cd1_w   1.0920749f
#define y2_cd2    -1.2010785f // FY
#define y2_cd2_h  -1.0183833f
#define y2_cd2_l  -0.7599558f
#define y2_cd2_w  -1.1537624f
#define y2_cd      1.4008173f // EIKLQR
#define y2_cd_p    1.8467097f
#define y2_ce1     1.2013461f // FY
#define y2_ce1_h   0.8563749f
#define y2_ce2    -1.2010785f // FY
#define y2_ce2_w  -0.6707077f
#define y2_ce3_w  -2.5365643f
#define y2_ce_k    2.4445438f
#define y2_ce_m    2.6543252f
#define y2_cg2    -0.7816257f // ITV
#define y2_cg      0.0000000f // DEFHIKLMNQRVWY
#define y2_cg_p    0.4313438f
#define y2_ch2_w  -2.8929773f
#define y2_cz2_w  -1.5205149f
#define y2_cz3_w  -3.3887598f
#define y2_cz     -0.0059738f // FY
#define y2_cz_r    2.1380849f
#define y2_c       1.5796792f // ACDEFGHIKLMNPQRSTVWY
#define y2_nd1_h   1.1614907f
#define y2_nd2_n  -1.1711487f
#define y2_ne1_w   0.7002982f
#define y2_ne2_h  -0.4589020f
#define y2_ne2_q   1.5043442f
#define y2_ne_r    2.4080171f
#define y2_nh1_r   0.8909794f
#define y2_nh2_r   3.1270457f
#define y2_nv_p    2.3629299f
#define y2_nz_k    1.8220952f
#define y2_n       2.4110593f // ACDEFGHIKLMNPQRSTVWY
#define y2_od1     1.0628332f // DN
#define y2_od2_d  -1.0627261f
#define y2_oe1     2.3574845f // EQ
#define y2_oe2_e   1.5359470f
#define y2_og      0.0476256f // ST
#define y2_oh_y   -0.0059759f
#define y2_o       2.0412172f // ACDEFGHIKLMNPQRSTVWY
#define y2_sd_m    1.6644581f
#define y2_sg_c   -0.0363704f

#define z2_ca      0.0000000f // ACDEFGHIKLMNPQRSTVWY
#define z2_cb      0.0000000f // ACDEFHIKLMNQRSTVWY
#define z2_cb_p    0.0661247f
#define z2_cd1     0.0000000f // FY
#define z2_cd1_w   0.0000028f
#define z2_cd2     0.0000000f // FY
#define z2_cd2_h  -0.0009351f
#define z2_cd2_l   1.2162614f
#define z2_cd2_w   0.0008309f
#define z2_cd      0.0000007f // EIKLQR
#define z2_cd_p    0.4052198f
#define z2_ce1     0.0000000f // FY
#define z2_ce1_h   0.0000084f
#define z2_ce2     0.0000000f // FY
#define z2_ce2_w   0.0013971f
#define z2_ce3_w   0.0019356f
#define z2_ce_k    0.0000013f
#define z2_ce_m    0.0000004f
#define z2_cg2    -1.2132623f // ITV
#define z2_cg      0.0000000f // DEFHIKLMNQRVWY
#define z2_cg_p    0.8161961f
#define z2_ch2_w   0.0029114f
#define z2_cz2_w   0.0008706f
#define z2_cz3_w   0.0027443f
#define z2_cz      0.0000000f // FY
#define z2_cz_r    0.0000010f
#define z2_c       1.2012238f // ACDEFGHIKLMNPQRSTVWY
#define z2_nd1_h   0.0000002f
#define z2_nd2_n   0.0000000f
#define z2_ne1_w  -0.0006771f
#define z2_ne2_h  -0.0009374f
#define z2_ne2_q   0.0000007f
#define z2_ne_r    0.0000011f
#define z2_nh1_r   0.0000004f
#define z2_nh2_r   0.0000015f
#define z2_nv_p    0.0057931f
#define z2_nz_k    0.0000008f
#define z2_n       0.0000000f // ACDEFGHIKLMNPQRSTVWY
#define z2_od1     0.0000000f // DN
#define z2_od2_d   0.0000000f
#define z2_oe1     0.0000011f // EQ
#define z2_oe2_e   0.0000007f
#define z2_og      0.0000000f // ST
#define z2_oh_y    0.0000000f
#define z2_o       2.2604272f // ACDEFGHIKLMNPQRSTVWY
#define z2_sd_m    0.0000009f
#define z2_sg_c    0.0000000f

#define r_ca      2.0000000f // ACDEFGHIKLMNPQRSTVWY
#define r_cb      2.0000000f // ACDEFHIKLMNQRSTVWY
#define r_cb_p    2.0000000f
#define r_cd1     2.0000000f // FY
#define r_cd1_w   2.0000000f
#define r_cd2     2.0000000f // FY
#define r_cd2_h   2.0000000f
#define r_cd2_l   2.0000000f
#define r_cd2_w   2.0000000f
#define r_cd      2.0000000f // EIKLQR
#define r_cd_p    2.0000000f
#define r_ce1     2.0000000f // FY
#define r_ce1_h   2.0000000f
#define r_ce2     2.0000000f // FY
#define r_ce2_w   2.0000000f
#define r_ce3_w   2.0000000f
#define r_ce_k    2.0000000f
#define r_ce_m    2.0000000f
#define r_cg2     2.0000000f // ITV
#define r_cg      2.0000000f // DEFHIKLMNQRVWY
#define r_cg_p    2.0000000f
#define r_ch2_w   2.0000000f
#define r_cz2_w   2.0000000f
#define r_cz3_w   2.0000000f
#define r_cz      2.0000000f // FY
#define r_cz_r    2.0000000f
#define r_c       2.0000000f // ACDEFGHIKLMNPQRSTVWY
#define r_nd1_h   1.7500000f
#define r_nd2_n   1.7500000f
#define r_ne1_w   1.7500000f
#define r_ne2_h   1.7500000f
#define r_ne2_q   1.7500000f
#define r_ne_r    1.7500000f
#define r_nh1_r   1.7500000f
#define r_nh2_r   1.7500000f
#define r_nv_p    1.7500000f
#define r_nz_k    1.7500000f
#define r_n       1.7500000f // ACDEFGHIKLMNPQRSTVWY
#define r_od1     1.5500000f // DN
#define r_od2_d   1.5500000f
#define r_oe1     1.5500000f // EQ
#define r_oe2_e   1.5500000f
#define r_og      1.5500000f // ST
#define r_oh_y    1.5500000f
#define r_o       1.5500000f // ACDEFGHIKLMNPQRSTVWY
#define r_sd_m    1.9000000f
#define r_sg_c    1.9000000f

enum UATOM {
  CA, // ACDEFGHIKLMNPQRSTVWY
  CB, // ACDEFHIKLMNQRSTVWY
  CB_P,
  CD1, // FY
  CD1_W,
  CD2, // FY
  CD2_H,
  CD2_L,
  CD2_W,
  CD, // EIKLQR
  CD_P,
  CE1, // FY
  CE1_H,
  CE2, // FY
  CE2_W,
  CE3_W,
  CE_K,
  CE_M,
  CG2, // ITV
  CG, // DEFHIKLMNQRVWY
  CG_P,
  CH2_W,
  CZ2_W,
  CZ3_W,
  CZ, // FY
  CZ_R,
  C, // ACDEFGHIKLMNPQRSTVWY
  ND1_H,
  ND2_N,
  NE1_W,
  NE2_H,
  NE2_Q,
  NE_R,
  NH1_R,
  NH2_R,
  NV_P,
  NZ_K,
  N, // ACDEFGHIKLMNPQRSTVWY
  OD1, // DN
  OD2_D,
  OE1, // EQ
  OE2_E,
  OG, // ST
  OH_Y,
  O, // ACDEFGHIKLMNPQRSTVWY
  SD_M,
  SG_C
};

struct VEC;
struct MAT;
struct MAT rowsf(float xx, float xy, float xz, float yx, float yy, float yz, float zx, float zy, float zz) ;
struct MAT colsf(float xx, float yx, float zx, float xy, float yy, float zy, float xz, float yz, float zz) ;
struct MAT rows(struct VEC const rx, struct VEC const ry, struct VEC const rz) ;
struct MAT cols(struct VEC const cx, struct VEC const cy, struct VEC const cz) ;
struct MAT multmm(struct MAT const a, struct MAT const b) ;
struct VEC multmv(struct MAT const a, struct VEC const b) ;
struct VEC multfv(float const a, struct VEC const v) ;
struct MAT multfm(float const a, struct MAT const m) ;
struct VEC crossvv(struct VEC const a, struct VEC const b) ;
struct VEC addvv(struct VEC const a, struct VEC const b) ;
struct VEC subvv(struct VEC const a, struct VEC const b) ;
float dotvv(struct VEC const a, struct VEC const b) ;
float length2v(struct VEC v) ;
float length2f(float const x, float const y, float const z) ;
float lengthv(struct VEC v) ;
float lengthf(float const x, float const y, float const z) ;
struct VEC normalizedv(struct VEC v) ;
struct VEC normalizedf(float const x, float const y, float const z) ;
struct VEC proj(struct VEC const a, struct VEC const v) ;
struct VEC pproj(struct VEC const a, struct VEC const v) ;
struct MAT projectionMAT(struct VEC const a) ;
struct MAT projectionMATf(float const x, float const y, float const z) ;
struct MAT rotationMAT(struct VEC const a, float const t) ;
struct MAT rotationMATf(float const x, float const y, float const z, float const t) ;


__kernel void k_square(
                       __global float* input,
                       __global float* output
                       ){
  size_t i0 = get_global_id(x2_cb);
  size_t i1 = get_global_id(1);
  size_t i2 = get_global_id(2);
  size_t g0 = get_global_size(0);
  size_t g1 = get_global_size(1);
  //size_t g2 = get_global_size(2);
  size_t i = i2*(g0*g1) + i1*g0 + i0;
  output[i] = input[i] * input[i];

}



__kernel void testbb(
                     __constant float16 *bb,
                     __global   float16 *out
                     ){
  /* float const cenx = bb[get_global_id(1)].sc; */
  /* float const ceny = bb[get_global_id(1)].sd; */
  /* float const cenz = bb[get_global_id(1)].se; */
  /* float const chi2 = 2.0f*M_PI_F*(float)(get_global_id(0)) / (float)(get_global_size(0)); */
  /* float const cos2 = native_cos( chi2 ); */
  /* float const sin2 = native_sin( chi2 ); */
  for( float chi1 = 0.0f; chi1 < 2.0f*M_PI_F; chi1 += M_PI_F/64.0f ) {
    //float const cos1 = native_cos( chi1 );
    //float const sin1 = native_sin( chi1 );
    ;
    // local2global
    // global2local

  }

  out[ get_global_size(0)*get_global_id(1)+get_global_id(0) ] = 0;
}




struct VEC {
  float x,y,z;
#ifdef __cplusplus
  VEC() {}
  VEC(float _x, float _y, float _z) { x=_x; y=_y; z=_z; }
  VEC(Vec v) {
    x = v.x();
    y = v.y();
    z = v.z();
  }
  Vec xyzVector() { return Vec(x,y,z); }
#endif
};
inline struct VEC vec(float x, float y, float z) { struct VEC v; v.x=x; v.y=y; v.z=z; return v; }
struct MAT {
  float xx,xy,xz,
    yx,yy,yz,
    zx,zy,zz;
#ifdef __cplusplus
  MAT() {}
  MAT(Mat m) {
    xx = m.xx();
    yx = m.yx();
    zx = m.zx();
    xy = m.xy();
    yy = m.yy();
    zy = m.zy();
    xz = m.xz();
    yz = m.yz();
    zz = m.zz();
  }
  Mat xyzMatrix() { return Mat::rows(xx,xy,xz,yx,yy,yz,zx,zy,zz); };
#endif
};
inline struct MAT rowsf(float xx, float xy, float xz, float yx, float yy, float yz, float zx, float zy, float zz) {
  struct MAT m;
  m.xx=xx; m.xy=xy; m.xz=xz;
  m.yx=yx; m.yy=yy; m.yz=yz;
  m.zx=zx; m.zy=zy; m.zz=zz;
  return m;
}
inline struct MAT colsf(float xx, float yx, float zx, float xy, float yy, float zy, float xz, float yz, float zz) {
  struct MAT m;
  m.xx=xx; m.xy=xy; m.xz=xz;
  m.yx=yx; m.yy=yy; m.yz=yz;
  m.zx=zx; m.zy=zy; m.zz=zz;
  return m;
}
inline struct MAT rows(struct VEC const rx, struct VEC const ry, struct VEC const rz) {
  struct MAT m;
  m.xx=rx.x; m.xy=rx.y; m.xz=rx.z;
  m.yx=ry.x; m.yy=ry.y; m.yz=ry.z;
  m.zx=rz.x; m.zy=rz.y; m.zz=rz.z;
  return m;
}
inline struct MAT cols(struct VEC const cx, struct VEC const cy, struct VEC const cz) {
  struct MAT m;
  m.xx=cx.x; m.xy=cy.x; m.xz=cz.x;
  m.yx=cx.y; m.yy=cy.y; m.yz=cz.y;
  m.zx=cx.z; m.zy=cy.z; m.zz=cz.z;
  return m;
}
inline struct MAT multmm(struct MAT const a, struct MAT const b) {
  struct MAT c;
  c.xx = mad(a.xx,b.xx,mad(a.xy,b.yx,a.xz*b.zx));
  c.xy = mad(a.xx,b.xy,mad(a.xy,b.yy,a.xz*b.zy));
  c.xz = mad(a.xx,b.xz,mad(a.xy,b.yz,a.xz*b.zz));
  c.yx = mad(a.yx,b.xx,mad(a.yy,b.yx,a.yz*b.zx));
  c.yy = mad(a.yx,b.xy,mad(a.yy,b.yy,a.yz*b.zy));
  c.yz = mad(a.yx,b.xz,mad(a.yy,b.yz,a.yz*b.zz));
  c.zx = mad(a.zx,b.xx,mad(a.zy,b.yx,a.zz*b.zx));
  c.zy = mad(a.zx,b.xy,mad(a.zy,b.yy,a.zz*b.zy));
  c.zz = mad(a.zx,b.xz,mad(a.zy,b.yz,a.zz*b.zz));
  return c;
}
inline struct VEC multmv(struct MAT const a, struct VEC const b) {
  struct VEC c;
  c.x = mad(a.xx,b.x,mad(a.xy,b.y,a.xz*b.z));
  c.y = mad(a.yx,b.x,mad(a.yy,b.y,a.yz*b.z));
  c.z = mad(a.zx,b.x,mad(a.zy,b.y,a.zz*b.z));
  return c;
}
inline struct VEC multfv(float const a, struct VEC const v) {
  struct VEC r;
  r.x = a*v.x;
  r.y = a*v.y;
  r.z = a*v.z;
  return r;
}
inline struct MAT multfm(float const a, struct MAT const m) {
  struct MAT r;
  r.xx= a*m.xx;  r.xy= a*m.xy;  r.xz= a*m.xz;
  r.yx= a*m.yx;  r.yy= a*m.yy;  r.yz= a*m.yz;
  r.zx= a*m.zx;  r.zy= a*m.zy;  r.zz= a*m.zz;
  return r;
}
inline struct VEC crossvv(struct VEC const a, struct VEC const b) {
  struct VEC r;
  r.x = mad(a.y,b.z,-a.z*b.y);
  r.y = mad(a.z,b.x,-a.x*b.z);
  r.z = mad(a.x,b.y,-a.y*b.x);
  return r;
}
inline struct VEC addvv(struct VEC const a, struct VEC const b) {
  struct VEC r;
  r.x = a.x+b.x;
  r.y = a.y+b.y;
  r.z = a.z+b.z;
  return r;
}
inline struct VEC subvv(struct VEC const a, struct VEC const b) {
  struct VEC r;
  r.x = a.x-b.x;
  r.y = a.y-b.y;
  r.z = a.z-b.z;
  return r;
}
inline float dotvv(struct VEC const a, struct VEC const b) {
  return mad(a.x,b.x,mad(a.y,b.y,a.z*b.z));
}
inline float length2v(struct VEC v) {
  return mad(v.x,v.x,mad(v.y,v.y,v.z*v.z));
}
inline float length2f(float const x, float const y, float const z) {
  return mad(x,x,mad(y,y,z*z));
}
inline float lengthv(struct VEC v) {
  return native_sqrt(mad(v.x,v.x,mad(v.y,v.y,v.z*v.z)));
}
inline float lengthf(float const x, float const y, float const z) {
  return native_sqrt(mad(x,x,mad(y,y,z*z)));
}
inline struct VEC normalizedv(struct VEC v) {
  return multfv( native_recip(lengthv(v)) , v );
}
inline struct VEC normalizedf(float const x, float const y, float const z) {
  struct VEC r;
  float l = 1.0f / lengthf(x,y,z);
  r.x = x*l;
  r.y = y*l;
  r.z = z*l;
  return r;
}
inline struct VEC proj(struct VEC const a, struct VEC const v) {
  float d = dotvv(a,v) / length2v(a);
  struct VEC r;
  r.x = d*a.x;
  r.y = d*a.y;
  r.z = d*a.z;
  return r;
}
inline struct VEC pproj(struct VEC const a, struct VEC const v) {
  float d = native_divide( dotvv(a,v), length2v(a) );
  struct VEC r;
  r.x = v.x-d*a.x;
  r.y = v.y-d*a.y;
  r.z = v.z-d*a.z;
  return r;
}
inline struct MAT projectionMAT(struct VEC const a) {
  struct MAT P;
  float l2 = 1.0f/length2v(a);
  P.xx=l2*a.x*a.x; P.xy=l2*a.x*a.y; P.xz=l2*a.x*a.z;
  P.yx=l2*a.y*a.x; P.yy=l2*a.y*a.y; P.yz=l2*a.y*a.z;
  P.zx=l2*a.z*a.x; P.zy=l2*a.z*a.y; P.zz=l2*a.z*a.z;
  return P;
}
inline struct MAT projectionMATf(float const x, float const y, float const z) {
  struct MAT P;
  float l2 = native_divide(1.0f,length2f(x,y,z));
  P.xx=l2*x*x; P.xy=l2*x*y; P.xz=l2*x*z;
  P.yx=l2*y*x; P.yy=l2*y*y; P.yz=l2*y*z;
  P.zx=l2*z*x; P.zy=l2*z*y; P.zz=l2*z*z;
  return P;
}
inline struct MAT rotationMAT(struct VEC const a, float const t) {
  struct VEC const n = normalizedv(a);
  float sin_t = native_sin(t);
  float cos_t = native_cos(t);
  struct MAT R = multfm(1.0f-cos_t,projectionMAT(n));
  R.xx += cos_t;       R.xy -= sin_t * n.z; R.xz += sin_t * n.y;
  R.yx += sin_t * n.z; R.yy += cos_t;       R.yz -= sin_t * n.x;
  R.zx -= sin_t * n.y; R.zy += sin_t * n.x; R.zz += cos_t;
  return R;
}
inline struct MAT rotationMATf(float const x, float const y, float const z, float const t) {
  struct VEC const n = normalizedf(x,y,z);
  float sin_t = native_sin( t );
  float cos_t = native_cos( t );
  struct MAT R = multfm(1.0f-cos_t,projectionMAT(n));
  R.xx += cos_t;       R.xy -= sin_t * n.z; R.xz += sin_t * n.y;
  R.yx += sin_t * n.z; R.yy += cos_t;       R.yz -= sin_t * n.x;
  R.zx -= sin_t * n.y; R.zy += sin_t * n.x; R.zz += cos_t;
  return R;
}



#define _N 0u
#define CA 3u
#define _C 6u
#define Xi 0u
#define Yi 1u
#define Zi 2u
#define COS_C_N_CA 0.5254717f
#define SIN_C_N_CA 0.8508111f
#define COS_N_CA_C 0.3616246f
#define SIN_N_CA_C 0.9323238f
#define COS_CA_C_N 0.4415059f
#define SIN_CA_C_N 0.8972584f
#define DIS_N_CA 1.458001f
#define DIS_CA_C 1.523258f
#define DIS_C_N  1.328685f

__kernel void refold(
                     __global const float *tor,
                     __global const uint  *nres,
                     __global       float *out
                     ){

  uint N = nres[0];

  __local float bb[64*9];
  __local float b2[64*9];

  uint const i = get_global_id(0);
  uint const i9 = 9u*i;
  if( i < N-1u ) {
    __local float *XX = ((i==0u)?b2:bb);
    uint const i2 = 9u*(i+1u);
    XX[i9+_N+Xi] =  0.0f;
    XX[i9+_N+Yi] =  SIN_N_CA_C * DIS_N_CA;
    XX[i9+_N+Zi] = -DIS_CA_C - COS_N_CA_C * DIS_N_CA;
    XX[i9+CA+Xi] =  0.0f;
    XX[i9+CA+Yi] =  0.0f;
    XX[i9+CA+Zi] = -DIS_CA_C;
    XX[i9+_C+Xi] =  0.0f;
    XX[i9+_C+Yi] =  0.0f;
    XX[i9+_C+Zi] =  0.0f;
    b2[i2+_N+Xi] =  0.0f;
    b2[i2+_N+Yi] =  0.0f;
    b2[i2+_N+Zi] =  0.0f;
    b2[i2+CA+Xi] =  0.0f;
    b2[i2+CA+Yi] =  0.0f;
    b2[i2+CA+Zi] =  0.0f;
    b2[i2+_C+Xi] =  0.0f;
    b2[i2+_C+Yi] =  0.0f;
    b2[i2+_C+Zi] =  0.0f;

    // this first block could be merged into init!!!
    { // rot CA-C-N-CA, rot CA-N-C and drop
      float const COS_CA_C = cos(tor[3u*i+1u]);
      float const SIN_CA_C = sin(tor[3u*i+1u]);
      float const Nx = XX[i9+_N+Xi];
      float const Ny = XX[i9+_N+Yi];
      XX[i9+_N+Xi] = mad(  COS_CA_C , Nx, + SIN_CA_C * Ny );
      XX[i9+_N+Yi] = mad( -SIN_CA_C , Nx, + COS_CA_C * Ny );
      // CA x/y are 0 at start, no need to rot!
    }
    { // rot CA_C_N bond angle
      float const Ny  = XX[i9+_N+Yi];
      float const Nz  = XX[i9+_N+Zi];
      float const CAy = XX[i9+CA+Yi];
      float const CAz = XX[i9+CA+Zi];
      XX[i9+_N+Yi] = mad( COS_CA_C_N ,  Ny, -SIN_CA_C_N *  Nz );
      XX[i9+_N+Zi] = mad( SIN_CA_C_N ,  Ny,  COS_CA_C_N *  Nz );
      XX[i9+CA+Yi] = mad( COS_CA_C_N , CAy, -SIN_CA_C_N * CAz );
      XX[i9+CA+Zi] = mad( SIN_CA_C_N , CAy,  COS_CA_C_N * CAz );
    }
    XX[i9+_N+Zi] -= DIS_C_N;
    XX[i9+CA+Zi] -= DIS_C_N;
    XX[i9+_C+Zi] -= DIS_C_N;
    { // rot omega2
      float const COS_C_N = cos(tor[3u*i+2u]);
      float const SIN_C_N = sin(tor[3u*i+2u]);
      float const  Nx = XX[i9+_N+Xi];
      float const  Ny = XX[i9+_N+Yi];
      float const CAx = XX[i9+CA+Xi];
      float const CAy = XX[i9+CA+Yi];
      // float const  Cx = XX[i9+_C+Xi];
      // float const  Cy = XX[i9+_C+Yi];
      XX[i9+_N+Xi] = mad(  COS_C_N ,  Nx, + SIN_C_N *  Ny );
      XX[i9+_N+Yi] = mad( -SIN_C_N ,  Nx, + COS_C_N *  Ny );
      XX[i9+CA+Xi] = mad(  COS_C_N , CAx, + SIN_C_N * CAy );
      XX[i9+CA+Yi] = mad( -SIN_C_N , CAx, + COS_C_N * CAy );
    }
    { // rot C_N_CA angle
      float const  Ny = XX[i9+_N+Yi];
      float const  Nz = XX[i9+_N+Zi];
      float const CAy = XX[i9+CA+Yi];
      float const CAz = XX[i9+CA+Zi];
      float const  Cy = XX[i9+_C+Yi];
      float const  Cz = XX[i9+_C+Zi];
      XX[i9+_N+Yi] = mad( COS_C_N_CA ,  Ny, -SIN_C_N_CA *  Nz );
      XX[i9+_N+Zi] = mad( SIN_C_N_CA ,  Ny,  COS_C_N_CA *  Nz );
      XX[i9+CA+Yi] = mad( COS_C_N_CA , CAy, -SIN_C_N_CA * CAz );
      XX[i9+CA+Zi] = mad( SIN_C_N_CA , CAy,  COS_C_N_CA * CAz );
      XX[i9+_C+Yi] = mad( COS_C_N_CA ,  Cy, -SIN_C_N_CA *  Cz );
      XX[i9+_C+Zi] = mad( SIN_C_N_CA ,  Cy,  COS_C_N_CA *  Cz );
    }
    XX[i9+_N+Zi] -= DIS_N_CA;
    XX[i9+CA+Zi] -= DIS_N_CA;
    XX[i9+_C+Zi] -= DIS_N_CA;
    b2[i2+_N+Zi] -= DIS_N_CA;
    { // rot phi2
      float const COS_N_CA = cos(tor[3u*i+3u]);
      float const SIN_N_CA = sin(tor[3u*i+3u]);
      float const  Nx = XX[i9+_N+Xi];
      float const  Ny = XX[i9+_N+Yi];
      float const CAx = XX[i9+CA+Xi];
      float const CAy = XX[i9+CA+Yi];
      float const  Cx = XX[i9+_C+Xi];
      float const  Cy = XX[i9+_C+Yi];
      float const N2x = b2[i2+_N+Xi];
      float const N2y = b2[i2+_N+Yi];
      XX[i9+_N+Xi] = mad(  COS_N_CA ,  Nx, SIN_N_CA *  Ny );
      XX[i9+_N+Yi] = mad( -SIN_N_CA ,  Nx, COS_N_CA *  Ny );
      XX[i9+CA+Xi] = mad(  COS_N_CA , CAx, SIN_N_CA * CAy );
      XX[i9+CA+Yi] = mad( -SIN_N_CA , CAx, COS_N_CA * CAy );
      XX[i9+_C+Xi] = mad(  COS_N_CA ,  Cx, SIN_N_CA *  Cy );
      XX[i9+_C+Yi] = mad( -SIN_N_CA ,  Cx, COS_N_CA *  Cy );
    }
    { // rot C_CA_N angle
      float const  Ny = XX[i9+_N+Yi];
      float const  Nz = XX[i9+_N+Zi];
      float const CAy = XX[i9+CA+Yi];
      float const CAz = XX[i9+CA+Zi];
      float const  Cy = XX[i9+_C+Yi];
      float const  Cz = XX[i9+_C+Zi];
      float const N2y = b2[i2+_N+Yi];
      float const N2z = b2[i2+_N+Zi];
      XX[i9+_N+Yi] = mad( COS_N_CA_C ,  Ny, -SIN_N_CA_C *  Nz );
      XX[i9+_N+Zi] = mad( SIN_N_CA_C ,  Ny,  COS_N_CA_C *  Nz );
      XX[i9+CA+Yi] = mad( COS_N_CA_C , CAy, -SIN_N_CA_C * CAz );
      XX[i9+CA+Zi] = mad( SIN_N_CA_C , CAy,  COS_N_CA_C * CAz );
      XX[i9+_C+Yi] = mad( COS_N_CA_C ,  Cy, -SIN_N_CA_C *  Cz );
      XX[i9+_C+Zi] = mad( SIN_N_CA_C ,  Cy,  COS_N_CA_C *  Cz );
      b2[i2+_N+Yi] = mad( COS_N_CA_C , N2y, -SIN_N_CA_C * N2z );
      b2[i2+_N+Zi] = mad( SIN_N_CA_C , N2y,  COS_N_CA_C * N2z );
    }
    //TR<<F(5,2,XX[i9+_N+Xi])<<" "<<F(5,2,XX[i9+_N+Yi])<<" "<<F(5,2,XX[i9+CA+Xi])<<" "<<F(5,2,XX[i9+CA+Yi])<<" "<<F(5,2,XX[i9+_C+Xi])<<" "<<F(5,2,XX[i9+_C+Yi])<<" "<<F(5,2,XX[i9+_C+Xi])<<" "<<F(5,2,XX[i9+_C+Yi])<<endl;
    XX[i9+_N+Zi] -= DIS_CA_C;
    XX[i9+CA+Zi] -= DIS_CA_C;
    XX[i9+_C+Zi] -= DIS_CA_C;
    b2[i2+_N+Zi] -= DIS_CA_C;
    b2[i2+CA+Zi] -= DIS_CA_C;

  }

  for(uint c = 2u; c < N*2u-3u; c=2u*c) {
    uint j = get_global_id(0);
    if( j < N ) {
      uint i = (max(0,((int)j))/c)*c+c/2;
      if(j > i || i > N-2u) continue;;
      uint const i9 = 9u*(i);
      struct MAT R;
//barrier(CLK_LOCAL_MEM_FENCE);
      if(c<4u) { // skip "to" if 1st iter
        struct VEC const az = normalizedv(         vec(bb[i9+6u]-bb[i9+3u],bb[i9+7u]-bb[i9+4u],bb[i9+8u]-bb[i9+5u]) );
        struct VEC const ay = normalizedv(pproj(az,vec(bb[i9+0u]-bb[i9+3u],bb[i9+1u]-bb[i9+4u],bb[i9+2u]-bb[i9+5u])));
        R = cols(crossvv(ay,az),ay,az);
      } else {
        struct VEC       az = normalizedv(         vec(bb[i9+6u]-bb[i9+3u],bb[i9+7u]-bb[i9+4u],bb[i9+8u]-bb[i9+5u]) );
        struct VEC       ay = normalizedv(pproj(az,vec(bb[i9+0u]-bb[i9+3u],bb[i9+1u]-bb[i9+4u],bb[i9+2u]-bb[i9+5u])));
        struct MAT const to = cols(crossvv(ay,az),ay,az);
        az = normalizedv(                   vec(b2[i9+6u]-b2[i9+3u],b2[i9+7u]-b2[i9+4u],b2[i9+8u]-b2[i9+5u]) );
        ay = normalizedv(pproj(az,          vec(b2[i9+0u]-b2[i9+3u],b2[i9+1u]-b2[i9+4u],b2[i9+2u]-b2[i9+5u])));
        R = multmm(to,rows(crossvv(ay,az),ay,az));
      }
      struct VEC T = vec(b2[i9+0u],b2[i9+1u],b2[i9+2u]);
      T = multmv(R,T);  T.x = bb[i9+0u]-T.x;  T.y = bb[i9+1u]-T.y;  T.z = bb[i9+2u]-T.z;
      uint const start = max((int)i-(int)c/2,0);
//barrier(CLK_LOCAL_MEM_FENCE);
      uint const j9 = 9u*j;
      __local float *XX = ((j==i-c/2u&&j!=0u) ? bb : b2);
      struct VEC v1 = multmv(R,vec(XX[j9+0u],XX[j9+1u],XX[j9+2u]));
      struct VEC v2 = multmv(R,vec(XX[j9+3u],XX[j9+4u],XX[j9+5u]));
      struct VEC v3 = multmv(R,vec(XX[j9+6u],XX[j9+7u],XX[j9+8u]));
      XX[j9+0u]=v1.x+T.x; XX[j9+1u]=v1.y+T.y; XX[j9+2u]=v1.z+T.z;
      XX[j9+3u]=v2.x+T.x; XX[j9+4u]=v2.y+T.y; XX[j9+5u]=v2.z+T.z;
      XX[j9+6u]=v3.x+T.x; XX[j9+7u]=v3.y+T.y; XX[j9+8u]=v3.z+T.z;
    }
  }
  out[i9+0u] = b2[i9+0u];
  out[i9+1u] = b2[i9+1u];
  out[i9+2u] = b2[i9+2u];
  out[i9+3u] = b2[i9+3u];
  out[i9+4u] = b2[i9+4u];
  out[i9+5u] = b2[i9+5u];
  out[i9+6u] = b2[i9+6u];
  out[i9+7u] = b2[i9+7u];
  out[i9+8u] = b2[i9+8u];
}
